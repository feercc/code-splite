---
description: 策略模式的设计与实现
---

# 策略模式

策略模式指的是定义一系列的算法，将其一个个封装，然后将不变的部分和变化的部分分隔开，也就是将算法的使用和算法的实现分离开，在 js 中使用对象可以简化一些操作

```javascript
const definedConfig = {
  S: (val) => val*4,
  A: (val) => val*3,
  B: (val) => val*2,
}
const calculate = (level, base) => definedConfig[level](base)

// 使用 calculate 的方法就能够计算得到想要的结果，把算法和实现分离
```

## 动画效果

```javascript
const tween = {
  linear: (t, b, c, d) => (c * t) / d + b,
  caseIn: (t, b, c, d) => c * (t /= d) * t + b,
  strongEaseIn: (t, b, c, d) => c * (t /= d) * t * t * t * t + b,
  strongEaseOut: (t, b, c, d) => c * ((t = t / d - 1) * t * t * t * t + 1) + b,
  sineaseIn: (t, b, c, d) => c * (t /= d) * t * t + b,
  sineaseOut: (t, b, c, d) => c * ((t = t / d - 1) * t * t + 1) + b
};
class Animate {
  constructor(dom) {
    this.dom = dom;
    this.startTime = 0;
    this.startPos = 0;
    this.endPos = 0;
    this.propertyName = null;
    this.easing = null;
    this.duration = null;
  }
  start(propertyName, endPos, duration, easing) {
    this.startTime = +new Date();
    this.startPos = this.dom.getBoundingClientRect()[propertyName];
    this.propertyName = propertyName;
    this.endPos = endPos;
    this.duration = duration;
    this.easing = tween[easing];
    let timer = setInterval(() => {
      if (this.step() === false) {
        clearInterval(timer);
      }
    }, 19);
  }
  step() {
    let t = +new Date();
    if (t >= this.startTime + this.duration) {
      this.update(this.endPos);
      return false;
    }
    let pos = this.easing(
      t - this.startTime,
      this.startPos,
      this.endPos - this.startPos,
      this.duration
    );
    this.update(pos);
  }
  update(pos) {
    this.dom.style[this.propertyName] = pos + "px";
  }
}

const div = document.getElementById("div");
const animate = new Animate(div);
animate.start("left", 500, 3000, "strongEaseOut");

```

## 表单校验

```javascript
const strategies = {
  isNonEmpty: function (value, errorMsg) {
    if (value === "" || value === null || value === undefined) {
      return errorMsg;
    }
  },
  minLength: function (value, length, errorMsg) {
    if (value.length < length) {
      return errorMsg;
    }
  },
  isMobile: function (value, errorMsg) {
    if (!/^1[3|5|8][0-9]{9}$/.test(value)) {
      return errorMsg;
    }
  }
};

class Validator {
  constructor() {
    this.cache = [];
  }
  add(value, rules) {
    for (let rule of rules) {
      let strategyAry = rule.strategy.split(":");
      let errorMsg = rule.errorMsg;
      this.cache.push(function () {
        let strategy = strategyAry.shift();
        strategyAry.unshift(value);
        strategyAry.push(errorMsg);
        return strategies[strategy].apply(null, strategyAry);
      });
    }
  }
  start() {
    for (let validatorFunc of this.cache) {
      let errorMsg = validatorFunc();
      if (errorMsg) {
        return errorMsg;
      }
    }
  }
}

// 使用
let registerForm = document.getElementById("registerForm");
let validataFunc = function () {
  let validator = new Validator();
  validator.add(registerForm.userName.value, [
    {
      strategy: "isNonEmpty",
      errorMsg: "用户名不能为空"
    },
    {
      strategy: "minLength:6",
      errorMsg: "用户名长度不能小于6位"
    }
  ]);
  validator.add(registerForm.password.value, [
    {
      strategy: "minLength:6",
      errorMsg: "密码长度不能小于6位"
    }
  ]);
  validator.add(registerForm.phoneNumber.value, [
    {
      strategy: "isMobile",
      errorMsg: "手机号码格式不正确"
    }
  ]);
  let errorMsg = validator.start();
  return errorMsg;
};

```

策略模式利用组合、委托以及多态等技术和思想，避免多重条件选择，易扩展、理解和切换，避免很多重复的复制粘贴的工作